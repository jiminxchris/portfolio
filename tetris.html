<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레트로 & 현대 테트리스</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 및 Inter 폰트 설정 */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background: #111827; /* 기본 어두운 배경 */
        }

        /* --- 모던 테마 --- */
        .modern {
            background: linear-gradient(135deg, #4f46e5, #a855f7);
            font-family: 'Inter', sans-serif;
            color: #1f2937;
        }
        .modern .game-board-container {
            border: 8px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: rgba(0, 0, 0, 0.5);
        }
        .modern .stats-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .modern .stats-panel h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
            letter-spacing: 0.05em;
        }
        .modern .stats-panel .stat-label {
            color: #6b7280;
            font-weight: 600;
        }
        .modern .stats-panel .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #111827;
        }
        .modern .controls-title {
            color: #4b5563;
        }
        .modern .control-key {
            background: #e5e7eb;
            color: #374151;
        }
        .modern .theme-switch-btn {
            background-color: #6366f1;
            color: white;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .modern .theme-switch-btn:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }
        .modern .overlay {
            background-color: rgba(255, 255, 255, 0.8);
            color: #1f2937;
        }


        /* --- 레트로 테마 --- */
        .retro {
            background: #000;
            font-family: 'Press Start 2P', cursive;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
        }
        .retro .game-wrapper::before, .retro .game-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        /* 스캔 라인 효과 */
        .retro .game-wrapper::before {
             background: linear-gradient(to bottom, rgba(0,0,0,0) 50%, rgba(0,0,0,0.4) 50%);
             background-size: 100% 4px;
             z-index: 100;
             animation: scanlines 10s linear infinite;
        }
        /* CRT 모니터의 가장자리 글로우 효과 */
        .retro .game-wrapper::after {
            box-shadow: inset 0 0 100px 50px rgba(0, 255, 0, 0.15);
        }
        .retro .game-title, .retro .retro-border-text {
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
        }
        .retro .game-board-container {
            border: 2px solid #0f0;
            border-style: dashed;
            padding: 16px;
        }
        .retro .stats-panel {
            border: none;
            background: transparent;
        }
        .retro hr {
            border-color: #0f0;
        }
        .retro .control-key {
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 6px;
        }
        .retro .theme-switch-btn {
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .retro .theme-switch-btn:hover {
            background: #0f0;
            color: #000;
            text-shadow: none;
        }
        .retro .overlay {
            background-color: rgba(0, 0, 0, 0.9);
            color: #0f0;
            border: 2px solid #0f0;
        }
        
        @keyframes scanlines {
            from { background-position: 0 0; }
            to { background-position: 0 200px; }
        }
    </style>
</head>
<body class="modern">

    <div id="game-container" class="game-wrapper w-full h-screen flex flex-col justify-center items-center p-4 transition-all duration-500 ease-in-out">
        
        <!-- 레트로 테마 전용 제목 -->
        <div id="retro-header" class="hidden w-full max-w-4xl mb-4">
            <h1 class="game-title text-center text-2xl tracking-widest">== ASCII TETRIS - 1985 RETRO ==</h1>
            <p class="retro-border-text text-center text-xl">==================================</p>
        </div>

        <div class="flex flex-col md:flex-row gap-8 items-center justify-center w-full max-w-4xl">
            <!-- 게임 보드 -->
            <div class="game-board-container rounded-lg">
                <canvas id="tetris-canvas" width="300" height="600"></canvas>
            </div>

            <!-- 정보 패널 -->
            <div class="stats-panel w-full max-w-xs p-6 rounded-lg">
                <h2 class="text-center font-bold mb-4 tracking-wider">GAME STATS</h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span class="stat-label">SCORE:</span>
                        <span id="score" class="stat-value">000000</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="stat-label">LEVEL:</span>
                        <span id="level" class="stat-value">01</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="stat-label">LINES:</span>
                        <span id="lines" class="stat-value">000</span>
                    </div>
                </div>

                <hr class="my-6 border-gray-300">

                <h3 class="text-center font-bold mb-4 tracking-wider controls-title">CONTROLS:</h3>
                <div class="space-y-2 text-sm">
                    <p class="flex items-center justify-between"><span>← →</span> <span>Move Left/Right</span></p>
                    <p class="flex items-center justify-between"><span>↓</span> <span>Soft Drop</span></p>
                    <p class="flex items-center justify-between"><span>↑</span> <span>Rotate</span></p>
                    <p class="flex items-center justify-between"><span class="control-key font-sans rounded px-2 py-1">SPACE</span> <span>Hard Drop</span></p>
                    <p class="flex items-center justify-between"><span class="control-key font-sans rounded px-2 py-1">R</span> <span>Restart</span></p>
                    <p class="flex items-center justify-between"><span class="control-key font-sans rounded px-2 py-1">ESC</span> <span>Pause/Resume</span></p>
                </div>

                <button id="theme-switch-btn" class="theme-switch-btn w-full mt-8 py-3 rounded-lg font-bold text-lg tracking-wider focus:outline-none">
                    SWITCH TO RETRO
                </button>
            </div>
        </div>
    </div>

    <!-- 오버레이: 일시정지, 게임 오버 -->
    <div id="overlay" class="overlay absolute inset-0 w-screen h-screen flex-col justify-center items-center text-4xl font-bold tracking-widest text-center hidden">
        <p id="overlay-text"></p>
        <p id="restart-message" class="text-lg mt-4 hidden">Press 'R' to restart</p>
    </div>

    <script>
        const canvas = document.getElementById('tetris-canvas');
        const context = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        const themeSwitchBtn = document.getElementById('theme-switch-btn');
        const body = document.body;
        const retroHeader = document.getElementById('retro-header');
        
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlay-text');
        const restartMessage = document.getElementById('restart-message');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;

        context.canvas.width = COLS * BLOCK_SIZE;
        context.canvas.height = ROWS * BLOCK_SIZE;

        const COLORS = {
            modern: [
                null,
                '#FF0D72', // Z
                '#0DC2FF', // S
                '#0DFF72', // I
                '#F538FF', // T
                '#FF8E0D', // L
                '#FFE138', // O
                '#3877FF', // J
            ],
            retro: '#0f0'
        };

        const SHAPES = [
            [], // 0
            [[1, 1, 0], [0, 1, 1], [0, 0, 0]], // Z
            [[0, 2, 2], [2, 2, 0], [0, 0, 0]], // S
            [[0, 3, 0, 0], [0, 3, 0, 0], [0, 3, 0, 0], [0, 3, 0, 0]], // I
            [[0, 4, 0], [4, 4, 4], [0, 0, 0]], // T
            [[5, 0, 0], [5, 0, 0], [5, 5, 0]], // L
            [[6, 6], [6, 6]], // O
            [[0, 0, 7], [0, 0, 7], [0, 7, 7]], // J
        ];

        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let piece;
        let score = 0;
        let level = 1;
        let lines = 0;
        let isPaused = false;
        let isGameOver = false;
        let currentTheme = 'modern';
        
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        class Piece {
            constructor(shape, context) {
                this.shape = shape;
                this.ctx = context;
                this.y = 0;
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
            }

            draw() {
                this.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            drawBlock(this.x + x, this.y + y, value);
                        }
                    });
                });
            }

            move(p) {
                this.x = p.x;
                this.y = p.y;
                this.shape = p.shape;
            }
        }
        
        function drawBlock(x, y, value) {
            const color = currentTheme === 'modern' ? COLORS.modern[value] : COLORS.retro;
            
            if (currentTheme === 'modern') {
                context.fillStyle = color;
                context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                context.strokeStyle = 'rgba(0,0,0,0.2)';
                context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            } else { // retro
                context.fillStyle = color;
                context.font = `${BLOCK_SIZE * 0.9}px 'Press Start 2P'`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                // 중앙에 # 그리기
                context.fillText('#', (x + 0.5) * BLOCK_SIZE, (y + 0.5) * BLOCK_SIZE);
            }
        }

        function drawBoard() {
             if (currentTheme === 'modern') {
                // 그리드 그리기
                context.lineWidth = 0.5;
                context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                for (let x = 0; x < COLS + 1; x++) {
                    context.beginPath();
                    context.moveTo(x * BLOCK_SIZE, 0);
                    context.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                    context.stroke();
                }
                for (let y = 0; y < ROWS + 1; y++) {
                    context.beginPath();
                    context.moveTo(0, y * BLOCK_SIZE);
                    context.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
                    context.stroke();
                }
            }
            
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        drawBlock(x, y, value);
                    }
                });
            });
        }
        
        function newPiece() {
            const rand = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            const shape = SHAPES[rand];
            piece = new Piece(shape, context);
        }

        function isValidMove(matrix, offsetX, offsetY) {
            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[y].length; x++) {
                    if (matrix[y][x] !== 0) {
                        let newX = offsetX + x;
                        let newY = offsetY + y;

                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return false;
                        }
                        if (board[newY] && board[newY][newX] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function rotate(matrix) {
            const N = matrix.length;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - 1 - j][i])
            );
            return result;
        }

        function merge() {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        board[piece.y + y][piece.x + x] = value;
                    }
                });
            });
        }
        
        function checkLines() {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y > 0; --y) {
                for (let x = 0; x < COLS; ++x) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }

                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                linesCleared++;
            }
            
            if (linesCleared > 0) {
                lines += linesCleared;
                score += (linesCleared * 10) * level;
                 // 10줄마다 레벨업
                if (lines >= level * 10) {
                    level++;
                    dropInterval *= 0.9; // 속도 증가
                }
                updateStats();
            }
        }

        function resetGame() {
            board.forEach(row => row.fill(0));
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            isGameOver = false;
            isPaused = false;
            overlay.classList.add('hidden');
            newPiece();
            updateStats();
            gameLoop();
        }

        function drop() {
            if (isPaused || isGameOver) return;
            
            const p = { ...piece };
            p.y++;

            if (isValidMove(p.shape, p.x, p.y)) {
                piece.move(p);
            } else {
                merge();
                checkLines();
                newPiece();
                if (!isValidMove(piece.shape, piece.x, piece.y)) {
                    isGameOver = true;
                    showOverlay('GAME OVER');
                }
            }
            dropCounter = 0;
        }

        function updateStats() {
            scoreElement.textContent = score.toString().padStart(6, '0');
            levelElement.textContent = level.toString().padStart(2, '0');
            linesElement.textContent = lines.toString().padStart(3, '0');
        }

        function showOverlay(text) {
            overlayText.textContent = text;
            restartMessage.style.display = (text === 'GAME OVER') ? 'block' : 'none';
            overlay.classList.remove('hidden');
            overlay.classList.add('flex');
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                showOverlay('PAUSED');
            } else {
                overlay.classList.add('hidden');
                gameLoop();
            }
        }
        
        function gameLoop(time = 0) {
            if (isPaused || isGameOver) {
                return;
            }
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                drop();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            // 캔버스 클리어
            if (currentTheme === 'modern') {
                 context.fillStyle = 'rgba(0, 0, 0, 0.5)';
            } else {
                context.fillStyle = '#000';
            }
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBoard();
            piece.draw();
        }

        // 키보드 이벤트 처리
        document.addEventListener('keydown', event => {
            if (isGameOver) {
                if(event.key.toUpperCase() === 'R') resetGame();
                return;
            }
            if(isPaused && event.key !== 'Escape') return;

            const p = { ...piece };
            
            switch (event.key) {
                case 'ArrowLeft':
                    p.x--;
                    if (isValidMove(p.shape, p.x, p.y)) piece.move(p);
                    break;
                case 'ArrowRight':
                    p.x++;
                    if (isValidMove(p.shape, p.x, p.y)) piece.move(p);
                    break;
                case 'ArrowDown':
                    drop();
                    break;
                case 'ArrowUp':
                    p.shape = rotate(p.shape);
                    if (isValidMove(p.shape, p.x, p.y)) piece.move(p);
                    break;
                case ' ': // Space
                     event.preventDefault(); // 스페이스바의 기본 동작(버튼 클릭)을 막습니다.
                     while (isValidMove(piece.shape, piece.x, piece.y + 1)) {
                        piece.y++;
                    }
                    drop();
                    break;
                case 'Escape':
                    togglePause();
                    break;
                case 'r':
                case 'R':
                    resetGame();
                    break;
            }
        });
        
        // 테마 전환
        themeSwitchBtn.addEventListener('click', () => {
            if (currentTheme === 'modern') {
                currentTheme = 'retro';
                body.classList.remove('modern');
                body.classList.add('retro');
                themeSwitchBtn.textContent = 'SWITCH TO MODERN';
                retroHeader.classList.remove('hidden');
            } else {
                currentTheme = 'modern';
                body.classList.remove('retro');
                body.classList.add('modern');
                themeSwitchBtn.textContent = 'SWITCH TO RETRO';
                retroHeader.classList.add('hidden');
            }
            draw(); // 테마 변경 후 즉시 다시 그리기
        });

        // 초기화
        updateStats();
        newPiece();
        gameLoop();
    </script>
</body>
</html>

